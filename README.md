# Крэйг Скотт. CMake - Практическое руководство (14-е издание, вольный перевод).

## Глава 27. Установка.

После всей тяжелой работы по разработке исходного кода проекта, созданию его различных ресурсов, обеспечению надежности сборки и внедрению автоматизированных тестов, решающим является последний шаг - предоставление программного обеспечения для распространения. Он напрямую влияет на первое впечатление конечного пользователя о проекте и, если он выполнен некачественно, может привести к тому, что программное обеспечение будет отвергнуто еще до того, как им начнут пользоваться. Разработчики и пользователи могут иметь разные мнения относительно того, как проект должен распространяться. Для некоторых достаточно просто предоставить доступ к репозиторию исходного кода и ожидать, что конечные пользователи сами соберут его. Хотя это может быть частью модели поставки, не все конечные пользователи захотят участвовать в проекте на таком низком уровне. Вместо этого они часто ожидают получить готовый бинарный пакет, который можно установить и использовать на своей машине, предпочтительно через какую-то уже знакомую систему управления пакетами. Учитывая разнообразие менеджеров пакетов и их форматов, это может представлять собой сложную задачу для поставщика. Тем не менее, между большинством из них есть достаточно общих элементов, чтобы при разумном планировании можно было поддерживать большинство популярных менеджеров и охватить все основные платформы. Чем раньше на стадии проектирования будут рассмотрены способы поставки программного продукта, тем более гладко пройдут этапы упаковки и развертывания. Хорошей отправной точкой будет задать следующие вопросы до начала разработки или как можно раньше для существующих проектов:
- Какие платформы должны поддерживаться изначально или в будущем?
- Какие минимальные требования к версии API или SDK платформы для обеспечения функционала проекта?
- Какие форматы пакетов будут предпочтительны на каждой платформе? Может ли проект быть представлен в этих форматах? Есть ли какие-то конкретные форматы пакетов, которые важнее других или являются обязательными? Есть ли у любого из необходимых или желательных форматов пакетов требования к тому, как должно быть изложено, создано или поставлено программное обеспечение?
- Должны ли ресурсы проекта предоставляться в определенных форматах, разрешениях, местах и т. д.?
- Может ли конечный пользователь захотеть установить несколько версий программного обеспечения одновременно?
- Должно ли программное обеспечение поддерживать установку без административных привилегий?
- Можно ли сделать программное обеспечение перемещаемым (portable), чтобы пользователи могли установить его в любом месте своей системы (в том числе на любом диске, если речь идет о Windows)?
- Ожидается ли, что один или несколько исполняемых файлов проекта будут доступны на машине пользователя через переменную окружения PATH ? Есть ли части проекта, которые не должны быть доступны в PATH? Предоставляет ли проект что-либо, что другие проекты CMake могут захотеть использовать в своих собственных сборках (библиотеки, исполняемые файлы, заголовки, ресурсы и т. д.)?

Эти вопросы будут сильно влиять на то, как программа будет располагаться при установке, что, в свою очередь, повлияет на то, как исходный код должен получать доступ к своим ресурсам и так далее. Это может даже повлиять на функциональность программного обеспечения, поэтому понимание этих вопросов на ранних этапах может избавить от лишних усилий в дальнейшем.

Эта глава посвящена аспектам установки ПО и тому, как собрать необходимые файлы в нужных местах. В ней также показано, как сделать проект удобным для использования другими проектами CMake, обеспечив поддержку конфигурационных пакетов. Разработчики с некоторым опытом могут считать эти аспекты относящимися к сфере `make install`. Следующая глава завершает картину, обсуждая различные форматы пакетов, которые могут создавать CMake и CPack.

### 27.1. Каталог установки.

Понимание ограничений, накладываемых разными платформами, является важным шагом перед принятием решения о том, где должен быть расположен установленный продукт. Только после выяснения всех деталей проект CMake может приступить к определению того, что и куда устанавливать. Можно сделать несколько важных замечаний, которые потенциально могут оказать сильное влияние на компоновку проекта.
- Форматы Apple (пакеты, фреймворки и т. д.) жестко регламентированы и не предлагают особой гибкости, но это также позволяет четко определить, как проект должен структурировать свои продукты. Как уже говорилось в главе 24 «Возможности Apple», CMake уже обрабатывает большую часть этого автоматически на этапе сборки, делая приложение готовым к последней части процесса, управляемого Xcode, который выполняет окончательную подпись приложения, создание пакета и отправку в магазин приложений. Если этап установки вообще будет использоваться в CMake/CPack, то в основном для того, чтобы просто архивировать пакеты, которые следуют предписанной схеме.
- Для проектов, которые предполагается включить в состав дистрибутива Linux, почти наверняка существуют очень конкретные рекомендации по установке каждого типа файлов. Стандарт иерархии файловой системы (Filesystem Hierarchy Standard или FHS) является основой для компоновки большинства дистрибутивов, и многие другие системы на базе Unix придерживаются аналогичной структуры. FHS служит хорошим руководством по тому, как структурировать пакет, чтобы добиться гладкой и надежной установки на многих системах на базе Unix.
- Некоторые проекты могут захотеть сделать один или несколько исполняемых файлов доступными через переменную PATH, чтобы их можно было легко вызывать из терминала или командной строки. В Windows, если при установке проекта в PATH добавляется каталог, содержащий некоторые собственные DLL, другие приложения могут взять эти DLL вместо ожидаемых (например, из своих личных каталогов или одного из стандартных общесистемных мест). DLL из популярных наборов инструментов, таких как Qt, регулярно становятся жертвами такого сценария в результате того, что пакеты изменяют PATH так, как не должны. Если проект хочет расширить PATH для своих собственных исполняемых файлов, он должен убедиться, что в этом каталоге нет DLL, но это напрямую противоречит необходимости размещения DLL в том же каталоге, что и исполняемые файлы, чтобы Windows могла найти их во время выполнения. Типичным решением этой проблемы является создание каталога, содержащего только скрипты запуска, которые затем можно безопасно добавить в PATH.

#### 27.1.1. Относительные пути.

За исключением установки на платформы Apple, существует большая степень общности (или, по крайней мере, потенциальной общности) для всех основных платформ. Место установки можно представить как состоящее из базового пути и относительного расположения ниже этого пути. Базовый путь может быть чем-то вроде `/usr/...`, `/opt/...` или `C:\Program Files` и, очевидно, сильно варьируется между платформами, но относительное расположение ниже этой базовой точки часто очень похоже. Обычно исполняемые файлы (а для Windows еще и DLL) устанавливаются в каталог bin, библиотеки - в lib или какой-то другой, а заголовки - в каталог include. Другие типы файлов имеют несколько большую вариативность в том, куда они обычно устанавливаются, но эти три типа уже охватывают некоторые из наиболее важных типов файлов, устанавливаемых в проект.

В Windows есть еще один вариант - когда исполняемые файлы и библиотеки DLL помещаются в базовый каталог установки, а не в подкаталог bin. Хотя это относительно распространенная практика, она может привести к тому, что базовый каталог окажется довольно переполненным, и пользователям будет сложнее найти другие компоненты. Другая вариация - размещение сценариев запуска в подкаталоге с именем cmd, что позволяет отделить их от DLL в других каталогах, например bin. Желательно найти структуру каталогов, которая работает на большинстве платформ, поскольку это минимизирует специфическую для платформы логику, которую приходится реализовывать в исходном коде проекта. Если проект использует одну и ту же относительную структуру на всех платформах, приложению легче найти нужные ему файлы во время выполнения.

При отсутствии каких-либо других требований модуль GNUInstallDirs в CMake предоставляет очень удобный способ использования стандартной схемы расположения каталогов. Он согласуется с общими случаями, упомянутыми выше, а также предоставляет различные другие стандартные расположения, которые соответствуют как стандартам кодирования GNU, так и FHS. Если не учитывать базовый каталог установки (о нем речь пойдет в следующем разделе), эту схему можно использовать даже для установки в Windows. Начиная с CMake 3.14, ряд команд, связанных с установкой, берут свои значения по умолчанию из GNUInstallDirs или из вычисляемых значений, которые очень похожи. Использование модуля GNUInstallDirs довольно простое, он включается в состав, как и любой другой модуль:
```cmake
# Minimal inclusion, but see caveat further below
include(GNUInstallDirs)
```
Этот код создаст переменные уровня кэша с именами: CMAKE\_INSTALL\_\<dir\>, где \<dir\> обозначает конкретное местоположение. В документации модуля приведена полная информация обо всех вариантах. Вот некоторые из наиболее часто используемых:
- `BINDIR` Исполняемые файлы, скрипты и симлинки, предназначенные для непосредственного запуска конечными пользователями. По умолчанию используется значение bin.
- `SBINDIR` Аналогичен BINDIR, но предназначен для использования системным администратором. По умолчанию - sbin.
- `LIBDIR` Библиотеки и объектные файлы. По умолчанию - lib или какая-то его разновидность в зависимости от хоста/целевой платформы (включая, возможно, дополнительный подкаталог, специфичный для конкретной архитектуры).
- `LIBEXECDIR` Исполняемые файлы, которые не вызываются непосредственно пользователями, но могут быть запущены через сценарии запуска или симлинки, расположенные в BINDIR, или другими способами. По умолчанию - libexec.
- `INCLUDEDIR` Заголовочные файлы. По умолчанию - include.
- `DATAROOTDIR` Корневой каталог независимых от архитектуры данных, доступных только для чтения. Обычно не указывается напрямую, за исключением случаев, когда нужно обойти предостережения для DOCDIR.
- `DATADIR` Данные, не зависящие от архитектуры, такие как изображения и другие ресурсы, доступные только для чтения. По умолчанию совпадает с DATAROOTDIR и является предпочтительным способом ссылки на местоположение произвольных данных проекта, не охваченных другими определёнными местоположениями.
- `MANDIR` Документация в формате man. По умолчанию имеет значение DATAROOTDIR/man.
- `DOCDIR` Общая документация. По умолчанию DATAROOTDIR/doc/PROJECT_NAME (см. примечания ниже о том, почему полагаться на это значение по умолчанию относительно небезопасно).

Поскольку каждое местоположение определяется как переменная кэша, их можно переопределить при необходимости. Разработчики обычно не изменяют их, так как места установки должны находиться под контролем проекта. Однако даже для проекта изменение расположений по умолчанию обычно не рекомендуется, но может быть полезно, если проект хочет в основном следовать стандартной схеме и нуждается лишь в нескольких небольших изменениях. Особого упоминания заслуживает расположение DOCDIR, поскольку по умолчанию оно принимает значение, включающее переменную PROJECT_NAME. PROJECT_NAME обновляется при каждом вызове функции project() и поэтому может меняться в иерархии проектов. Модуль GNUInstallDirs устанавливает переменные кэша, только если они еще не определены, поэтому значение CMAKE\_INSTALL\_DOCDIR будет определяться тем, где впервые включен модуль GNUInstallDirs. Чтобы защититься от этого и позволить директории документации по умолчанию следовать иерархии проекта, проекты могут захотеть явно задавать расположение DOCDIR при каждом включении модуля (некэширующая переменная будет переопределять кэширующую переменную):
```cmake
# Explicitly set DOCDIR location each time
include(GNUInstallDirs)
set(CMAKE_INSTALL_DOCDIR ${CMAKE_INSTALL_DATAROOTDIR}/doc/${PROJECT_NAME})
```
В оставшейся части этой главы в примерах будут использоваться переменные CMAKE\_INSTALL\_\<dir\> для большинства относительных путей установки.

#### 27.1.2. Базовый каталог установки.

После определения относительного расположения установленных файлов необходимо определить базовое место установки. На это решение влияет целый ряд соображений, но, пожалуй, первый вопрос, на который нужно ответить, - должна ли установка быть перемещаемой (portable). Это означает, что можно использовать любую базовую точку установки, и при сохранении относительной компоновки установленный проект будет работать так, как нужно. Перемещаемость очень желательна и должна быть целью большинства проектов, поскольку она открывает больше возможностей для использования, например:
- Можно одновременно устанавливать несколько версий.
- Portable программы можно устанавливать на общие диски, которые могут иметь разные точки монтирования на машинах разных конечных пользователей.
- Набор самодостаточных перемещаемых файлов может быть легче упакован более широким спектром систем упаковки.
- Пользователи, не являющиеся администраторами, могут установить перемещаемый проект локально под своей учетной записью.

Не все проекты можно сделать перемещаемыми, некоторые должны размещать свои файлы в очень специфических местах (например, пакеты ядра). Некоторые проекты могут быть перемещаемыми за исключением нескольких конфигурационных файлов, и в этом случае полезной стратегией может быть обработка этих специфических файлов скриптом после установки (в следующей главе рассматривается этот способ для конкретных систем). Выбор базового места установки тесно связан с целевой платформой, и для каждой из них существуют свои общие правила и рекомендации. В Windows местом базовой установки обычно является подкаталог C:\Program Files, в то время как в большинстве других систем это /usr/local или подкаталог /opt. CMake предоставляет ряд элементов управления расположением базовой установки, чтобы в основном абстрагироваться от этих платформенных различий. Возможно, наиболее важной является переменная CMAKE\_INSTALL\_PREFIX, которая управляет базовым местом установки, когда пользователь собирает цель (цель может называться INSTALL в некоторых типах генераторов). По умолчанию CMAKE\_INSTALL\_PREFIX имеет значение C:\Program Files\${PROJECT_NAME} для Windows, и /usr/local для Unix-платформ.

При установке в Linux значение по умолчанию не соответствует стандарту File System Hierarchy. FHS требует, чтобы системные пакеты использовали базовое расположение / или /usr, причем последний вариант является предпочтительным. Для дополнительных пакетов они должны устанавливаться в /opt/\<package\> или /opt/\<provider\>, при этом рекомендуется использовать /opt/\<provider\>/\<package\>. Если используется \<provider\>, то формально ожидается, что это будет имя, зарегистрированное в LANANA, или просто доменное имя организации, предоставляющей пакет, в нижнем регистре. Это делается для того, чтобы избежать конфликтов между различными пакетами, пытающимися использовать одно и то же место базовой установки. Для большинства проектов на платформах, отличных от Windows, рекомендуется явно установить CMAKE\_INSTALL\_PREFIX на FHS-совместимый путь `/opt/...`. Как правило, это следует делать только в CMakeLists.txt верхнего уровня, и это должно быть защищено соответствующей проверкой, что проект действительно является верхним уровнем дерева исходных текстов:
```cmake
if(NOT WIN32 AND CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
  set(CMAKE_INSTALL_PREFIX "/opt/mycompany.com/${PROJECT_NAME}")
endif()
```
Для сценариев кросс-компиляции переменная CMAKE\_STAGING\_PREFIX может быть определена, чтобы обеспечить переопределение того, куда устанавливается правило установки. Это позволяет устанавливать в альтернативную часть файловой системы, сохраняя при этом все остальные эффекты CMAKE\_INSTALL\_PREFIX, такие как встраивание путей в устанавливаемые двоичные файлы (рассматривается в разделе 27.2.2, «RPATH», далее в этой главе). CMAKE\_STAGING\_PREFIX также влияет на пути поиска большинства команд `find_...()`.

Для некоторых сценариев упаковки, а также для тестирования процесса установки в отведенном для этого месте, CMake поддерживает переменную DESTDIR для платформ, отличных от Windows. DESTDIR - это не переменная CMake, а переменная, передаваемая инструменту сборки или задаваемая в качестве переменной окружения для чтения инструментом сборки. Она позволяет переназначить значение базового каталога установки относительно произвольного места, а не относительно корня файловой системы. Обычно она используется в командной строке при прямом вызове инструмента сборки, например:
```shell
make DESTDIR=/home/me/staging install
env DESTDIR=/home/me/staging ninja install
```
Функциональность DESTDIR концептуально похожа на CMAKE\_STAGING\_PREFIX, но DESTDIR указывается только во время установки и не влияет на такие вещи, как команды `find_...()`. CMAKE\_STAGING\_PREFIX сохраняется как переменная кэша, в то время как DESTDIR является переменной среды и не сохраняется между вызовами инструмента сборки. Еще более гибкий и удобный метод выполнения установки при использовании CMake 3.15 или более поздней версии см. в разделе 27.9, «Выполнение установки». Сочетание CMAKE\_INSTALL\_PREFIX, CMAKE\_STAGING\_PREFIX и DESTDIR дает проекту и разработчику гибкость в настройке базового места установки по мере необходимости и позволяет выполнять тестовые установки, не касаясь конечного места установки. Однако имейте в виду, что различные форматы упаковки могут иметь свои собственные базовые места установки по умолчанию и полностью игнорировать эти три переменные, предпочитая их собственным, специфичным для конкретного пакета.

### 27.2. Установка целей проекта

Когда структура каталогов установки определена, можно переходить к самому устанавливаемому содержимому. Проекты используют команду install(), чтобы определить, что устанавливать, где это должно быть расположено и так далее. У этой команды есть несколько различных форм, каждая из которых ориентирована на определенный тип сущности, который указывается первым аргументом команды. Одна из ключевых форм предназначена для установки целей, предоставляемых проектом (в отличие от импортируемых целей, предоставляемых чем-то внешним по отношению к проекту):
```cmake
install(TARGETS targets...
  [EXPORT exportName]
  [CONFIGURATIONS configs...]
  # RUNTIME_... dependency options require CMake 3.21 or later
  [RUNTIME_DEPENDENCIES runtimeDepArgs... | RUNTIME_DEPENDENCY_SET runtimeSetName]
  # One or more blocks of the following
  [ [entityType]
    [DESTINATION dir] # Mandatory for CMake 3.13 and earlier
    [PERMISSIONS permissions...]
    [NAMELINK_ONLY | NAMELINK_SKIP]
    [COMPONENT component]
    [NAMELINK_COMPONENT component] # CMake 3.12 or later only
    [EXCLUDE_FROM_ALL]
    [OPTIONAL]
    [CONFIGURATIONS configs...]
  ]...
  # Special case
  [INCLUDES DESTINATION incDirs...]
)
```
Сначала указывается одна или несколько целей, затем в блоках entityType указывается, как обрабатывать установку различных частей этих целей. В CMake 3.12 и более ранних версиях каждая из целей должна быть определена в той же области видимости, что и команда install(), но в CMake 3.13 это ограничение снято. Для всех версий CMake тип entityType должен быть одним из следующих:
- `RUNTIME` Установка исполняемых двоичных файлов. В Windows также устанавливается DLL-часть целевых библиотек. Пакеты Apple исключены.
- `LIBRARY` Установка общих библиотек на всех платформах, кроме Windows. Фреймворки Apple исключены.
- `ARCHIVE` Установка статических библиотек (все платформы). В Windows также устанавливается часть библиотеки импорта (т. е. .lib) целей общих библиотек. Фреймворки Apple исключены.
- `OBJECTS` Установка объектных файлов, связанных с объектными библиотеками (только CMake 3.9 или более поздняя версия).
- `FRAMEWORK` На платформах Apple устанавливаются фреймворки (общие или статические), включая любое содержимое, которое было скопировано в них (например, с помощью пользовательских правил POST_BUILD).
- `BUNDLE` На платформах Apple устанавливаются пакеты, включая любое содержимое, которое было в них скопировано.
- `PUBLIC_HEADER` На платформах, отличных от Apple, этот параметр устанавливает файлы, перечисленные в свойстве PUBLIC_HEADER целевой библиотеки фреймворка. На платформах Apple эти заголовочные файлы обрабатываются как часть типа сущности FRAMEWORK. Дальнейшее обсуждение см. в разделе 27.5.2, «Явные публичные и частные заголовки».
- `PRIVATE_HEADER` Аналогичен типу сущности PUBLIC\_HEADER, за исключением того, что затрагиваемое свойство цели - PRIVATE\_HEADER.
- `RESOURCE` На платформах, отличных от Apple, этот тип устанавливает файлы, перечисленные в свойстве RESOURCE цели фреймворка или пакета. На платформах Apple они устанавливаются как часть фреймворка или пакета.
- `FILE_SET` За этим свойством должно следовать имя устанавливаемого набора файлов (только в CMake 3.23 или более поздней версии). Подробнее об этом говорится в разделе 27.5.1, «Наборы файлов».

После entityType могут быть перечислены различные опции, которые применяются только к этому типу сущности. Например, ниже показано, как установить библиотеки таким образом, чтобы соответствующие части находились на своих местах на всех платформах (при условии, что это не фреймворки Apple):
```cmake
install(TARGETS MySharedLib MyStaticLib
  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
)
```
В приведенном выше примере показано, как с помощью параметра DESTINATION можно указать разные места для разных частей одной и той же цели. Команда достаточно гибкая, чтобы одновременно работать с несколькими целями разных типов. Для MySharedLib в Windows DLL будет установлена в место назначения RUNTIME, а библиотека импорта - в место назначения ARCHIVE. На других платформах общая библиотека будет установлена в место назначения LIBRARY. Статическая библиотека цели MyStaticLib будет установлена в место назначения ARCHIVE. CMake обычно выдает предупреждение или ошибку, если цель предоставляет определенную сущность, для которой нет соответствующего раздела entityType (например, одна из целей - статическая библиотека, но нет раздела ARCHIVE). В качестве исключения можно опустить entityType, и тогда опции, следующие за списком целей, будут применяться ко всем типам сущностей. Обычно это делается только в тех случаях, когда очевидно, что для перечисленных целей может быть только один тип сущности:
```cmake
# Targets are both executables, so specifying the entity type isn't needed
install(TARGETS exe1 exe2
  DESTINATION ${CMAKE_INSTALL_BINDIR}
)
```
В CMake 3.13 и более ранних версиях необходимо указывать DESTINATION. В CMake 3.14 это требование было смягчено, теперь можно указывать назначения по умолчанию для исполняемых файлов, статических библиотек и общих библиотек, но не для библиотек модулей, пакетов Apple или фреймворков. Публичные и частные заголовки, прикрепленные к библиотечным целям, также имеют назначения по умолчанию, как и наборы файлов HEADERS (см. раздел 27.5.1, «Наборы файлов»). Для поддерживаемых типов целей места назначения по умолчанию задаются теми же переменными CMAKE\_INSTALL\_..., что и в модуле GNUInstallDirs для этих объектов. Если такие переменные не определены (т.е. модуль GNUInstallDirs не был включен), вместо них будут использоваться жестко закодированные значения по умолчанию, которые в основном повторяют значения по умолчанию модуля GNUInstallDirs. Обратите внимание, что в жестко закодированных значениях по умолчанию отсутствует логика для обработки тонких различий между различными дистрибутивами Linux/Unix, поэтому проекты должны включать модуль GNUInstallDirs, чтобы получить наиболее широкую поддержку платформы. Жестко закодированные значения по умолчанию подробно описаны в документации CMake по команде install().
```cmake
include(GNUInstallDirs)
# Only legal with CMake 3.14 or later
install(TARGETS MyExe MySharedLib MyStaticLib)
```
Вышеописанное установит MyExe в CMAKE\_INSTALL\_BINDIR, MyStaticLib в CMAKE\_INSTALL\_LIBDIR и MySharedLib в одно или оба из этих двух мест в зависимости от платформы. Любые публичные или частные заголовки или наборы файлов HEADERS, прикрепленные к этим целям, будут установлены в CMAKE\_INSTALL\_INCLUDEDIR. Хотя это может быть очень удобно и лаконично, это заставляет проект требовать CMake 3.14 в качестве минимальной версии. В оставшейся части этой главы в большинстве примеров места назначения указываются явно, чтобы они оставались применимыми к самому широкому диапазону версий CMake. Опции, следующие за типом сущности, могут указывать не только место назначения. Они также могут переопределять разрешения по умолчанию с помощью опции PERMISSIONS, указывая одно или несколько тех же значений, что и для команды file(COPY), описанной в разделе 20.2, «Копирование файлов»:
```
OWNER_READ    OWNER_WRITE    OWNER_EXECUTE
GROUP_READ    GROUP_WRITE    GROUP_EXECUTE
WORLD_READ    WORLD_WRITE    WORLD_EXECUTE
SETUID        SETGID
```





