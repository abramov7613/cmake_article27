# Крэйг Скотт. CMake - Практическое руководство (14-е издание, вольный перевод).

## Глава 27. Установка.

После всей тяжелой работы по разработке исходного кода проекта, созданию его различных ресурсов, обеспечению надежности сборки и внедрению автоматизированных тестов, решающим является последний шаг - предоставление программного обеспечения для распространения. Он напрямую влияет на первое впечатление конечного пользователя о проекте и, если он выполнен некачественно, может привести к тому, что программное обеспечение будет отвергнуто еще до того, как им начнут пользоваться. Разработчики и пользователи могут иметь разные мнения относительно того, как проект должен распространяться. Для некоторых достаточно просто предоставить доступ к репозиторию исходного кода и ожидать, что конечные пользователи сами соберут его. Хотя это может быть частью модели поставки, не все конечные пользователи захотят участвовать в проекте на таком низком уровне. Вместо этого они часто ожидают получить готовый бинарный пакет, который можно установить и использовать на своей машине, предпочтительно через какую-то уже знакомую систему управления пакетами. Учитывая разнообразие менеджеров пакетов и их форматов, это может представлять собой сложную задачу для поставщика. Тем не менее, между большинством из них есть достаточно общих элементов, чтобы при разумном планировании можно было поддерживать большинство популярных менеджеров и охватить все основные платформы. Чем раньше на стадии проектирования будут рассмотрены способы поставки программного продукта, тем более гладко пройдут этапы упаковки и развертывания. Хорошей отправной точкой будет задать следующие вопросы до начала разработки или как можно раньше для существующих проектов:
- Какие платформы должны поддерживаться изначально или в будущем?
- Какие минимальные требования к версии API или SDK платформы для обеспечения функционала проекта?
- Какие форматы пакетов будут предпочтительны на каждой платформе? Может ли проект быть представлен в этих форматах? Есть ли какие-то конкретные форматы пакетов, которые важнее других или являются обязательными? Есть ли у любого из необходимых или желательных форматов пакетов требования к тому, как должно быть изложено, создано или поставлено программное обеспечение?
- Должны ли ресурсы проекта предоставляться в определенных форматах, разрешениях, местах и т. д.?
- Может ли конечный пользователь захотеть установить несколько версий программного обеспечения одновременно?
- Должно ли программное обеспечение поддерживать установку без административных привилегий?
- Можно ли сделать программное обеспечение перемещаемым (portable), чтобы пользователи могли установить его в любом месте своей системы (в том числе на любом диске, если речь идет о Windows)?
- Ожидается ли, что один или несколько исполняемых файлов проекта будут доступны на машине пользователя через переменную окружения PATH ? Есть ли части проекта, которые не должны быть доступны в PATH? Предоставляет ли проект что-либо, что другие проекты CMake могут захотеть использовать в своих собственных сборках (библиотеки, исполняемые файлы, заголовки, ресурсы и т. д.)?

Эти вопросы будут сильно влиять на то, как программа будет располагаться при установке, что, в свою очередь, повлияет на то, как исходный код должен получать доступ к своим ресурсам и так далее. Это может даже повлиять на функциональность программного обеспечения, поэтому понимание этих вопросов на ранних этапах может избавить от лишних усилий в дальнейшем.

Эта глава посвящена аспектам установки ПО и тому, как собрать необходимые файлы в нужных местах. В ней также показано, как сделать проект удобным для использования другими проектами CMake, обеспечив поддержку конфигурационных пакетов. Разработчики с некоторым опытом могут считать эти аспекты относящимися к сфере `make install`. Следующая глава завершает картину, обсуждая различные форматы пакетов, которые могут создавать CMake и CPack.

### 27.1. Каталог установки.

Понимание ограничений, накладываемых разными платформами, является важным шагом перед принятием решения о том, где должен быть расположен установленный продукт. Только после выяснения всех деталей проект CMake может приступить к определению того, что и куда устанавливать. Можно сделать несколько важных замечаний, которые потенциально могут оказать сильное влияние на компоновку проекта.
- Форматы Apple (пакеты, фреймворки и т. д.) жестко регламентированы и не предлагают особой гибкости, но это также позволяет четко определить, как проект должен структурировать свои продукты. Как уже говорилось в главе 24 «Возможности Apple», CMake уже обрабатывает большую часть этого автоматически на этапе сборки, делая приложение готовым к последней части процесса, управляемого Xcode, который выполняет окончательную подпись приложения, создание пакета и отправку в магазин приложений. Если этап установки вообще будет использоваться в CMake/CPack, то в основном для того, чтобы просто архивировать пакеты, которые следуют предписанной схеме.
- Для проектов, которые предполагается включить в состав дистрибутива Linux, почти наверняка существуют очень конкретные рекомендации по установке каждого типа файлов. Стандарт иерархии файловой системы (Filesystem Hierarchy Standard или FHS) является основой для компоновки большинства дистрибутивов, и многие другие системы на базе Unix придерживаются аналогичной структуры. FHS служит хорошим руководством по тому, как структурировать пакет, чтобы добиться гладкой и надежной установки на многих системах на базе Unix.
- Некоторые проекты могут захотеть сделать один или несколько исполняемых файлов доступными через переменную PATH, чтобы их можно было легко вызывать из терминала или командной строки. В Windows, если при установке проекта в PATH добавляется каталог, содержащий некоторые собственные DLL, другие приложения могут взять эти DLL вместо ожидаемых (например, из своих личных каталогов или одного из стандартных общесистемных мест). DLL из популярных наборов инструментов, таких как Qt, регулярно становятся жертвами такого сценария в результате того, что пакеты изменяют PATH так, как не должны. Если проект хочет расширить PATH для своих собственных исполняемых файлов, он должен убедиться, что в этом каталоге нет DLL, но это напрямую противоречит необходимости размещения DLL в том же каталоге, что и исполняемые файлы, чтобы Windows могла найти их во время выполнения. Типичным решением этой проблемы является создание каталога, содержащего только скрипты запуска, которые затем можно безопасно добавить в PATH.

#### 27.1.1. Относительные пути.

За исключением установки на платформы Apple, существует большая степень общности (или, по крайней мере, потенциальной общности) для всех основных платформ. Место установки можно представить как состоящее из базового пути и относительного расположения ниже этого пути. Базовый путь может быть чем-то вроде `/usr/...`, `/opt/...` или `C:\Program Files` и, очевидно, сильно варьируется между платформами, но относительное расположение ниже этой базовой точки часто очень похоже. Обычно исполняемые файлы (а для Windows еще и DLL) устанавливаются в каталог bin, библиотеки - в lib или какой-то другой, а заголовки - в каталог include. Другие типы файлов имеют несколько большую вариативность в том, куда они обычно устанавливаются, но эти три типа уже охватывают некоторые из наиболее важных типов файлов, устанавливаемых в проект.

В Windows есть еще один вариант - когда исполняемые файлы и библиотеки DLL помещаются в базовый каталог установки, а не в подкаталог bin. Хотя это относительно распространенная практика, она может привести к тому, что базовый каталог окажется довольно переполненным, и пользователям будет сложнее найти другие компоненты. Другая вариация - размещение сценариев запуска в подкаталоге с именем cmd, что позволяет отделить их от DLL в других каталогах, например bin. Желательно найти структуру каталогов, которая работает на большинстве платформ, поскольку это минимизирует специфическую для платформы логику, которую приходится реализовывать в исходном коде проекта. Если проект использует одну и ту же относительную структуру на всех платформах, приложению легче найти нужные ему файлы во время выполнения.

При отсутствии каких-либо других требований модуль GNUInstallDirs в CMake предоставляет очень удобный способ использования стандартной схемы расположения каталогов. Он согласуется с общими случаями, упомянутыми выше, а также предоставляет различные другие стандартные расположения, которые соответствуют как стандартам кодирования GNU, так и FHS. Если не учитывать базовый каталог установки (о нем речь пойдет в следующем разделе), эту схему можно использовать даже для установки в Windows. Начиная с CMake 3.14, ряд команд, связанных с установкой, берут свои значения по умолчанию из GNUInstallDirs или из вычисляемых значений, которые очень похожи. Использование модуля GNUInstallDirs довольно простое, он включается в состав, как и любой другой модуль:
```cmake
# Минимум включений, но см. примечание ниже
include(GNUInstallDirs)
```
Этот код создаст переменные уровня кэша с именами: CMAKE\_INSTALL\_\<dir\>, где \<dir\> обозначает конкретное местоположение. В документации модуля приведена полная информация обо всех вариантах. Вот некоторые из наиболее часто используемых:
- `BINDIR` Исполняемые файлы, скрипты и симлинки, предназначенные для непосредственного запуска конечными пользователями. По умолчанию используется значение bin.
- `SBINDIR` Аналогичен BINDIR, но предназначен для использования системным администратором. По умолчанию - sbin.
- `LIBDIR` Библиотеки и объектные файлы. По умолчанию - lib или какая-то его разновидность в зависимости от хоста/целевой платформы (включая, возможно, дополнительный подкаталог, специфичный для конкретной архитектуры).
- `LIBEXECDIR` Исполняемые файлы, которые не вызываются непосредственно пользователями, но могут быть запущены через сценарии запуска или симлинки, расположенные в BINDIR, или другими способами. По умолчанию - libexec.
- `INCLUDEDIR` Заголовочные файлы. По умолчанию - include.
- `DATAROOTDIR` Корневой каталог независимых от архитектуры данных, доступных только для чтения. Обычно не указывается напрямую, за исключением случаев, когда нужно обойти предостережения для DOCDIR.
- `DATADIR` Данные, не зависящие от архитектуры, такие как изображения и другие ресурсы, доступные только для чтения. По умолчанию совпадает с DATAROOTDIR и является предпочтительным способом ссылки на местоположение произвольных данных проекта, не охваченных другими определёнными местоположениями.
- `MANDIR` Документация в формате man. По умолчанию имеет значение DATAROOTDIR/man.
- `DOCDIR` Общая документация. По умолчанию DATAROOTDIR/doc/PROJECT_NAME (см. примечания ниже о том, почему полагаться на это значение по умолчанию относительно небезопасно).

Поскольку каждое местоположение определяется как переменная кэша, их можно переопределить при необходимости. Разработчики обычно не изменяют их, так как места установки должны находиться под контролем проекта. Однако даже для проекта изменение расположений по умолчанию обычно не рекомендуется, но может быть полезно, если проект хочет в основном следовать стандартной схеме и нуждается лишь в нескольких небольших изменениях. Особого упоминания заслуживает расположение DOCDIR, поскольку по умолчанию оно принимает значение, включающее переменную PROJECT_NAME. PROJECT_NAME обновляется при каждом вызове функции project() и поэтому может меняться в иерархии проектов. Модуль GNUInstallDirs устанавливает переменные кэша, только если они еще не определены, поэтому значение CMAKE\_INSTALL\_DOCDIR будет определяться тем, где впервые включен модуль GNUInstallDirs. Чтобы защититься от этого и позволить директории документации по умолчанию следовать иерархии проекта, проекты могут захотеть явно задавать расположение DOCDIR при каждом включении модуля (некэширующая переменная будет переопределять кэширующую переменную):
```cmake
# Явно задавайте расположение DOCDIR каждый раз
include(GNUInstallDirs)
set(CMAKE_INSTALL_DOCDIR ${CMAKE_INSTALL_DATAROOTDIR}/doc/${PROJECT_NAME})
```
В оставшейся части этой главы в примерах будут использоваться переменные CMAKE\_INSTALL\_\<dir\> для большинства относительных путей установки.

#### 27.1.2. Базовый каталог установки.

После определения относительного расположения установленных файлов необходимо определить базовое место установки. На это решение влияет целый ряд соображений, но, пожалуй, первый вопрос, на который нужно ответить, - должна ли установка быть перемещаемой (portable). Это означает, что можно использовать любую базовую точку установки, и при сохранении относительной компоновки установленный проект будет работать так, как нужно. Перемещаемость очень желательна и должна быть целью большинства проектов, поскольку она открывает больше возможностей для использования, например:
- Можно одновременно устанавливать несколько версий.
- Portable программы можно устанавливать на общие диски, которые могут иметь разные точки монтирования на машинах разных конечных пользователей.
- Набор самодостаточных перемещаемых файлов может быть легче упакован более широким спектром систем упаковки.
- Пользователи, не являющиеся администраторами, могут установить перемещаемый проект локально под своей учетной записью.

Не все проекты можно сделать перемещаемыми, некоторые должны размещать свои файлы в очень специфических местах (например, пакеты ядра). Некоторые проекты могут быть перемещаемыми за исключением нескольких конфигурационных файлов, и в этом случае полезной стратегией может быть обработка этих специфических файлов скриптом после установки (в следующей главе рассматривается этот способ для конкретных систем). Выбор базового места установки тесно связан с целевой платформой, и для каждой из них существуют свои общие правила и рекомендации. В Windows местом базовой установки обычно является подкаталог C:\Program Files, в то время как в большинстве других систем это /usr/local или подкаталог /opt. CMake предоставляет ряд элементов управления расположением базовой установки, чтобы в основном абстрагироваться от этих платформенных различий. Возможно, наиболее важной является переменная CMAKE\_INSTALL\_PREFIX, которая управляет базовым местом установки, когда пользователь собирает цель (цель может называться INSTALL в некоторых типах генераторов). По умолчанию CMAKE\_INSTALL\_PREFIX имеет значение C:\Program Files\${PROJECT_NAME} для Windows, и /usr/local для Unix-платформ.

При установке в Linux значение по умолчанию не соответствует стандарту File System Hierarchy. FHS требует, чтобы системные пакеты использовали базовое расположение / или /usr, причем последний вариант является предпочтительным. Для дополнительных пакетов они должны устанавливаться в /opt/\<package\> или /opt/\<provider\>, при этом рекомендуется использовать /opt/\<provider\>/\<package\>. Если используется \<provider\>, то формально ожидается, что это будет имя, зарегистрированное в LANANA, или просто доменное имя организации, предоставляющей пакет, в нижнем регистре. Это делается для того, чтобы избежать конфликтов между различными пакетами, пытающимися использовать одно и то же место базовой установки. Для большинства проектов на платформах, отличных от Windows, рекомендуется явно установить CMAKE\_INSTALL\_PREFIX на FHS-совместимый путь `/opt/...`. Как правило, это следует делать только в CMakeLists.txt верхнего уровня, и это должно быть защищено соответствующей проверкой, что проект действительно является верхним уровнем дерева исходных текстов:
```cmake
if(NOT WIN32 AND CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
  set(CMAKE_INSTALL_PREFIX "/opt/mycompany.com/${PROJECT_NAME}")
endif()
```
Для сценариев кросс-компиляции переменная CMAKE\_STAGING\_PREFIX может быть определена, чтобы обеспечить переопределение того, куда устанавливается правило установки. Это позволяет устанавливать в альтернативную часть файловой системы, сохраняя при этом все остальные эффекты CMAKE\_INSTALL\_PREFIX, такие как встраивание путей в устанавливаемые двоичные файлы (рассматривается в разделе 27.2.2, «RPATH», далее в этой главе). CMAKE\_STAGING\_PREFIX также влияет на пути поиска большинства команд `find_...()`.

Для некоторых сценариев упаковки, а также для тестирования процесса установки в отведенном для этого месте, CMake поддерживает переменную DESTDIR для платформ, отличных от Windows. DESTDIR - это не переменная CMake, а переменная, передаваемая инструменту сборки или задаваемая в качестве переменной окружения для чтения инструментом сборки. Она позволяет переназначить значение базового каталога установки относительно произвольного места, а не относительно корня файловой системы. Обычно она используется в командной строке при прямом вызове инструмента сборки, например:
```shell
make DESTDIR=/home/me/staging install
env DESTDIR=/home/me/staging ninja install
```
Функциональность DESTDIR концептуально похожа на CMAKE\_STAGING\_PREFIX, но DESTDIR указывается только во время установки и не влияет на такие вещи, как команды `find_...()`. CMAKE\_STAGING\_PREFIX сохраняется как переменная кэша, в то время как DESTDIR является переменной среды и не сохраняется между вызовами инструмента сборки. Еще более гибкий и удобный метод выполнения установки при использовании CMake 3.15 или более поздней версии см. в разделе 27.9, «Выполнение установки». Сочетание CMAKE\_INSTALL\_PREFIX, CMAKE\_STAGING\_PREFIX и DESTDIR дает проекту и разработчику гибкость в настройке базового места установки по мере необходимости и позволяет выполнять тестовые установки, не касаясь конечного места установки. Однако имейте в виду, что различные форматы упаковки могут иметь свои собственные базовые места установки по умолчанию и полностью игнорировать эти три переменные, предпочитая их собственным, специфичным для конкретного пакета.

### 27.2. Установка целей проекта

Когда структура каталогов установки определена, можно переходить к устанавливаемому содержимому. Команда `install()` используется чтобы определить, что устанавливать, где это должно быть расположено и так далее. У этой команды есть несколько различных форм, каждая из которых ориентирована на определенный тип сущности, который указывается первым аргументом команды. Одна из ключевых форм предназначена для установки целей, предоставляемых проектом (в отличие от импортируемых целей, предоставляемых чем-то внешним по отношению к проекту):
```cmake
install(TARGETS targets...
  [EXPORT exportName]
  [CONFIGURATIONS configs...]
  # RUNTIME_... опции требуют CMake 3.21 или более поздней версии
  [RUNTIME_DEPENDENCIES runtimeDepArgs... | RUNTIME_DEPENDENCY_SET runtimeSetName]
  # Один или несколько блоков из следующих
  [ [entityType]
    [DESTINATION dir] # Обязательно для CMake 3.13 и более ранних версий
    [PERMISSIONS permissions...]
    [NAMELINK_ONLY | NAMELINK_SKIP]
    [COMPONENT component]
    [NAMELINK_COMPONENT component] # только для CMake 3.12 или более поздняя версия
    [EXCLUDE_FROM_ALL]
    [OPTIONAL]
    [CONFIGURATIONS configs...]
  ]...
  # Special case
  [INCLUDES DESTINATION incDirs...]
)
```
Сначала указывается одна или несколько целей, затем в блоках entityType указывается тип различных частей этих целей и как их обрабатывать. В CMake 3.12 и более ранних версиях каждая из целей должна быть определена в той же области видимости, что и команда install(), но в CMake 3.13 это ограничение снято. Для всех версий CMake entityType должен иметь одно из следующих значений:
- `RUNTIME` Установка исполняемых двоичных файлов. В Windows также устанавливается DLL-часть целевых библиотек. Пакеты Apple исключены.
- `LIBRARY` Установка общих библиотек на всех платформах, кроме Windows. Фреймворки Apple исключены.
- `ARCHIVE` Установка статических библиотек (все платформы). В Windows также устанавливается часть библиотеки импорта (т. е. .lib) целей общих библиотек. Фреймворки Apple исключены.
- `OBJECTS` Установка объектных файлов, связанных с объектными библиотеками (только CMake 3.9 или более поздняя версия).
- `FRAMEWORK` На платформах Apple устанавливаются фреймворки (общие или статические), включая любое содержимое, которое было скопировано в них (например, с помощью пользовательских правил POST_BUILD).
- `BUNDLE` На платформах Apple устанавливаются пакеты, включая любое содержимое, которое было в них скопировано.
- `PUBLIC_HEADER` На платформах, отличных от Apple, этот параметр устанавливает файлы, перечисленные в свойстве PUBLIC_HEADER целевой библиотеки фреймворка. На платформах Apple эти заголовочные файлы обрабатываются как часть типа сущности FRAMEWORK. Дальнейшее обсуждение см. в разделе 27.5.2, «Явные публичные и частные заголовки».
- `PRIVATE_HEADER` Аналогичен типу сущности PUBLIC\_HEADER, за исключением того, что затрагиваемое свойство цели - PRIVATE\_HEADER.
- `RESOURCE` На платформах, отличных от Apple, этот тип устанавливает файлы, перечисленные в свойстве RESOURCE цели фреймворка или пакета. На платформах Apple они устанавливаются как часть фреймворка или пакета.
- `FILE_SET` За этим свойством должно следовать имя устанавливаемого набора файлов (только в CMake 3.23 или более поздней версии). Подробнее об этом говорится в разделе 27.5.1, «Наборы файлов».

После entityType могут быть перечислены различные опции, которые применяются только к этому типу сущности. Например, ниже показано, как установить библиотеки таким образом, чтобы соответствующие части находились на своих местах на всех платформах (при условии, что это не фреймворки Apple):
```cmake
install(TARGETS MySharedLib MyStaticLib
  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
)
```
В приведенном выше примере показано, как с помощью параметра DESTINATION можно указать разные места для разных частей одной и той же цели. Команда достаточно гибкая, чтобы одновременно работать с несколькими целями разных типов. Для MySharedLib в Windows DLL будет установлена в место назначения RUNTIME, а библиотека импорта - в место назначения ARCHIVE. На других платформах общая библиотека будет установлена в место назначения LIBRARY. Статическая библиотека цели MyStaticLib будет установлена в место назначения ARCHIVE. CMake обычно выдает предупреждение или ошибку, если цель предоставляет определенную сущность, для которой нет соответствующего раздела entityType (например, одна из целей - статическая библиотека, но нет раздела ARCHIVE). В качестве исключения можно опустить entityType, и тогда опции, следующие за списком целей, будут применяться ко всем типам сущностей. Обычно это делается только в тех случаях, когда очевидно, что для перечисленных целей может быть только один тип сущности:
```cmake
# Цели являются исполняемыми файлами, поэтому указывать тип сущности не нужно.
install(TARGETS exe1 exe2
  DESTINATION ${CMAKE_INSTALL_BINDIR}
)
```
В CMake 3.13 и более ранних версиях необходимо указывать DESTINATION. В CMake 3.14 это требование было смягчено, теперь можно указывать назначения по умолчанию для исполняемых файлов, статических библиотек и общих библиотек, но не для библиотек модулей, пакетов Apple или фреймворков. Публичные и частные заголовки, прикрепленные к библиотечным целям, также имеют назначения по умолчанию, как и наборы файлов HEADERS (см. раздел 27.5.1, «Наборы файлов»). Для поддерживаемых типов целей места назначения по умолчанию задаются теми же переменными CMAKE\_INSTALL\_..., что и в модуле GNUInstallDirs для этих объектов. Если такие переменные не определены (т.е. модуль GNUInstallDirs не был включен), вместо них будут использоваться жестко закодированные значения по умолчанию, которые в основном повторяют значения по умолчанию модуля GNUInstallDirs. Обратите внимание, что в жестко закодированных значениях по умолчанию отсутствует логика для обработки тонких различий между различными дистрибутивами Linux/Unix, поэтому проекты должны включать модуль GNUInstallDirs, чтобы получить наиболее широкую поддержку платформы. Жестко закодированные значения по умолчанию подробно описаны в документации CMake по команде install().
```cmake
include(GNUInstallDirs)
# Подходит только для CMake 3.14 или более поздней версии
install(TARGETS MyExe MySharedLib MyStaticLib)
```
Вышеописанный код установит MyExe в CMAKE\_INSTALL\_BINDIR, MyStaticLib в CMAKE\_INSTALL\_LIBDIR и MySharedLib в одно или оба из этих двух мест в зависимости от платформы. Любые публичные или частные заголовки или наборы файлов HEADERS, прикрепленные к этим целям, будут установлены в CMAKE\_INSTALL\_INCLUDEDIR. Хотя это может быть очень удобно и лаконично, это заставляет проект требовать CMake 3.14 в качестве минимальной версии. В оставшейся части этой главы в большинстве примеров места назначения указываются явно, чтобы они оставались применимыми к самому широкому диапазону версий CMake. Опции, следующие за типом сущности, могут указывать не только место назначения. Они также могут переопределять разрешения по умолчанию с помощью опции PERMISSIONS, указывая одно или несколько тех же значений, что и для команды file(COPY), описанной в разделе 20.2, «Копирование файлов»:
```
OWNER_READ    OWNER_WRITE    OWNER_EXECUTE
GROUP_READ    GROUP_WRITE    GROUP_EXECUTE
WORLD_READ    WORLD_WRITE    WORLD_EXECUTE
SETUID        SETGID
```
Как и в случае с `file(COPY)`, разрешения, не поддерживаемые платформой, будут просто проигнорированы. Обратите внимание, что CMake обычно устанавливает соответствующие разрешения для всех целей по умолчанию. Как правило, явное задание разрешений требуется только в том случае, если установленное место требует более строгих разрешений, чем обычно, или если необходимо добавить одно из разрешений SETUID или SETGID. Следующий пример демонстрирует оба сценария.
```cmake
# Предназначен для запуска только администратором, поэтому доступ может иметь только владелец.
install(TARGETS OnlyOwnerCanRunMe
  DESTINATION ${CMAKE_INSTALL_SBINDIR}
  PERMISSIONS
    OWNER_READ OWNER_WRITE OWNER_EXECUTE
)
# Установка с правами set-group
install(TARGETS RunAsGroup
  DESTINATION ${CMAKE_INSTALL_BINDIR}
  PERMISSIONS
    OWNER_READ OWNER_WRITE OWNER_EXECUTE
    GROUP_READ GROUP_EXECUTE SETGID
)
```
Для типа сущности LIBRARY некоторые платформы поддерживают создание символических ссылок, если для целевой библиотеки предоставлена информация о версии (см. раздел 22.3, «Версионирование общих библиотек»). Набор файлов и симлинков, которые могут существовать для разделяемой библиотеки, обычно выглядит следующим образом:
1. `libMyShared.so.1.3.2`
2. `libMyShared.so.1 --> libMyShared.so.1.3.2`
3. `libMyShared.so --> libMyShared.so.1`

где:
1. Актуальный версионный бинарник, собранный проектом.
2. Символическая ссылка, имя которой - название библиотеки и основная часть версии (major version).
3. Символическая ссылка, имя которой - не содержит сведений о версии (namelink). Это необходимо для того, чтобы библиотека была найдена, когда в командной строке компоновщика содержится опция типа -lMyShared.

При установке сущностей LIBRARY можно указать опции NAMELINK\_ONLY или NAMELINK\_SKIP. Опция NAMELINK\_ONLY приведет к установке только namelink, в то время как NAMELINK\_SKIP приведет к установке всего, кроме namelink. Если целевая библиотека не имеет сведений о версии или платформа не поддерживает namelinks, поведение этих двух опций меняется. В этом случае NAMELINK\_ONLY не будет устанавливать ничего, а NAMELINK\_SKIP установит настоящую библиотеку. Эти опции особенно полезны при создании отдельных пакетов для выполнения и разработки, когда часть namelink помещается в пакет для разработки, а остальные файлы/ссылки - в пакет для выполнения. Если задана опция NAMELINK\_ONLY, CMake не будет предупреждать об отсутствии блоков других типов сущностей библиотеки, не упомянутых в команде install(). Это необходимо, потому что NAMELINK\_SKIP и NAMELINK\_ONLY не могут быть заданы в одном вызове install(), их нужно разделить на отдельные вызовы (см. пример ниже).

В каждом разделе entityType также может быть указан параметр COMPONENT. Компоненты - это логическая группа, используемая в основном для упаковки и подробно рассматриваемая в следующей главе. Пока же думайте о них как о способе разделения различных наборов установки. Вышеупомянутый сценарий для раздельных пакетов выполнения и разработки может быть настроен следующим образом:
```cmake
install(TARGETS MyShared MyStatic
  RUNTIME
    DESTINATION ${CMAKE_INSTALL_BINDIR}
    COMPONENT MyProj_Runtime
  LIBRARY
    DESTINATION ${CMAKE_INSTALL_LIBDIR}
    NAMELINK_SKIP
    COMPONENT MyProj_Runtime
  ARCHIVE
    DESTINATION ${CMAKE_INSTALL_LIBDIR}
    COMPONENT MyProj_Development
)
# Поскольку задан NAMELINK_ONLY, CMake не будет жаловаться на отсутствие блока RUNTIME
install(TARGETS MyShared
  LIBRARY
    DESTINATION ${CMAKE_INSTALL_LIBDIR}
    NAMELINK_ONLY
    COMPONENT MyProj_Development
)
```
Начиная с CMake 3.12, доступен более простой способ разделения namelink на другой компонент с помощью опции NAMELINK_COMPONENT. Эта опция может использоваться вместе с COMPONENT, но только внутри блока LIBRARY. Используя эту новую опцию, можно выразить сказанное выше более лаконично:
```cmake
install(TARGETS MyShared MyStatic
  RUNTIME
    DESTINATION ${CMAKE_INSTALL_BINDIR}
    COMPONENT MyProj_Runtime
  LIBRARY
    DESTINATION ${CMAKE_INSTALL_LIBDIR}
    COMPONENT MyProj_Runtime
    NAMELINK_COMPONENT MyProj_Development # Требуется CMake 3.12 или более поздняя версия
  ARCHIVE
    DESTINATION ${CMAKE_INSTALL_LIBDIR}
    COMPONENT MyProj_Development
)
```
Если для блока не указан COMPONENT, он ассоциируется с компонентом по умолчанию, имя которого задается переменной CMAKE\_INSTALL\_DEFAULT\_COMPONENT\_NAME. Если эта переменная не задана, то в качестве имени компонента по умолчанию используется Unspecified. В качестве примера, когда может быть полезно изменить имя компонента по умолчанию, можно привести ситуацию, когда дочерний проект стороннего разработчика не использует никаких компонентов установки. Чтобы сохранить артефакты установки дочернего проекта отдельно от основного проекта, имя по умолчанию можно изменить непосредственно перед вызовом add\_subdirectory(), чтобы подтянуть дочерний проект к основной сборке. Опция EXCLUDE\_FROM\_ALL может быть использована для ограничения блока сущностей, чтобы он устанавливался только для специфических установок компонентов. По умолчанию установка не является компонентно-специфичной и устанавливаются все компоненты, но реализация упаковки может устанавливать определенные компоненты по отдельности. В CMake 3.12 была добавлена документация, показывающая, как это сделать и из командной строки. Для большинства проектов EXCLUDE\_FROM\_ALL вряд ли понадобится.

Ключевое слово OPTIONAL также используется редко. Если тип сущности цели должен присутствовать, но он отсутствует (например, библиотека импорта Windows DLL для секции типа сущности ARCHIVE), CMake не будет считать это ошибкой. Используйте эту опцию с осторожностью, так как она может маскировать неправильную конфигурацию логики сборки/установки. Блок типа сущности также можно сделать специфичным для конфигурации, добавив к нему опцию CONFIGURATIONS. Этот тип сущности будет установлен только в том случае, если текущий тип сборки является одним из перечисленных. Тип сущности не может быть указан более одного раза для одной команды install(), поэтому, если для разных конфигураций требуются разные детали, потребуется несколько вызовов. В следующем примере показано, как установить Debug и Release версии статических библиотек в разные каталоги:
```cmake
install(TARGETS MyStatic
  ARCHIVE
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/Debug
    CONFIGURATIONS Debug
)
install(TARGETS MyStatic
  ARCHIVE
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/Release
    CONFIGURATIONS Release RelWithDebInfo MinSizeRel
)
```
Ключевое слово CONFIGURATIONS также может предшествовать всем блокам сущностей и действовать как значение по умолчанию для тех, которые не предоставляют своих собственных переопределений конфигурации. В следующем примере все блоки устанавливаются только в сборки Release, за исключением блока ARCHIVE, который устанавливается в сборки Debug и Release.
```cmake
install(TARGETS MyShared MyStatic
  CONFIGURATIONS Release
  RUNTIME
    DESTINATION ${CMAKE_INSTALL_BINDIR}
  LIBRARY
    DESTINATION ${CMAKE_INSTALL_LIBDIR}
  ARCHIVE
    DESTINATION ${CMAKE_INSTALL_LIBDIR}
    CONFIGURATIONS Debug Release
)
```
Как использовать ключевые слова RUNTIME\_DEPENDENCIES и RUNTIME\_DEPENDENCY\_SET, смотрите в разделе 27.7.1, «Наборы зависимостей времени выполнения».

#### 27.2.1. Свойства INTERFACE.

Если цели экспортируются (об этом говорится в разделе 27.3, «Установка экспорта», ниже), они имеют возможность задавать свойства INTERFACE, которые будут использоваться целями других проектов, зависящих от экспортируемых. Эти свойства автоматически переносятся на установленную цель, но для учета различий между поставщиком и потребителем цели на стадиях сборки и установки требуется специальная обработка. Рассмотрим следующий пример кода:
```cmake
add_library(Foo STATIC ...)
target_include_directories(Foo
  INTERFACE
    ${CMAKE_CURRENT_BINARY_DIR}/somewhere
    ${MyProject_BINARY_DIR}/anotherDir
)
install(TARGETS Foo DESTINATION ...)
```
В сборке все, что ссылается на Foo, будет иметь абсолютные пути к `somewhere` и `anotherDir`,добавленные в путь поиска заголовочных файлов. Когда Foo будет установлен, он может быть упакован и развернут на совершенно другой машине. Очевидно, что пути к `somewhere` и `anotherDir` больше не будут иметь смысла, но приведенный выше пример все равно добавит их в путь поиска заголовков для нижележащих целей. Необходим способ сказать: «Используйте путь `Х` при сборке и путь `У` при установке», и именно это делают генераторые выражения BUILD\_INTERFACE и INSTALL\_INTERFACE:
```cmake
include(GNUInstallDirs)
target_include_directories(Foo
  INTERFACE
    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/somewhere>
    $<BUILD_INTERFACE:${MyProject_BINARY_DIR}/anotherDir>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)
```
$<BUILD\_INTERFACE:xxx> будет разрешаться в `xxx` на стадии сборки или в пустую строку при установке, тогда как $<INSTALL\_INTERFACE:yyy> делает обратное, гарантируя, что `yyy` будет добавлен только для установленной цели. В случае INSTALL\_INTERFACE `yyy` обычно является относительным путем, который рассматривается как относительный к базовому месту установки. Хотя путь поиска заголовков в дереве сборки может отличаться для разных целей, обычно после установки цели имеют один и тот же путь поиска заголовков. В приведенном выше примере CMAKE\_INSTALL\_INCLUDEDIR, скорее всего, будет повторяться для каждой цели, но указывать его отдельно для каждой цели - не самый удобный подход. Вместо этого можно использовать опцию INCLUDES команды install(), чтобы указать ту же информацию для группы целей. Все каталоги, указанные после INCLUDES DESTINATION, добавляются к свойству INTERFACE\_INCLUDE\_DIRECTORIES каждой установленной цели из списка. Это приводит к более краткому описанию путей поиска заголовочных файлов.
```cmake
add_library(MyStatic STATIC ...)
add_library(MyHeaderOnly INTERFACE ...)
target_include_directories(MyStatic
  PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/static_exports>
)
target_include_directories(MyHeaderOnly
  INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>
)
install(TARGETS MyStatic MyHeaderOnly
  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
  INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)
```
В отличие от других блоков типов сущностей, для INCLUDES DESTINATION можно перечислить несколько каталогов, если это необходимо, хотя на практике это, скорее всего, встречается реже. Также обратите внимание, что блок INCLUDES не поддерживает ни одну из других деталей, которые поддерживают другие блоки entityType. Он может указывать только ключевое слово DESTINATION, за которым следует одно или несколько местоположений.

#### 27.2.2. RPATH

Когда операционная система загружает библиотеку или исполняемый файл, она должна найти все другие общие библиотеки, с которыми был связан двоичный файл. На разных платформах существуют разные способы решения этой проблемы. Windows полагается на поиск всех необходимых библиотек путем поиска по местоположениям в переменной среды PATH, а также по каталогу, в котором находится двоичный файл. Другие платформы используют другие переменные среды, специально предназначенные для этой цели, такие как LD\_LIBRARY\_PATH или их вариации, в сочетании с другими механизмами, такими как библиотеки, перечисленные в файлах conf. Недостатком зависимости от переменных среды является то, что правильная настройка среды зависит от пользователя или процесса, загружающего двоичный файл. Во многих случаях пакет, предоставляющий двоичный файл, уже знает, где можно найти многие зависимые библиотеки, поскольку они могли быть частью одного и того же пакета. Большинство платформ, отличных от Windows, поддерживают двоичные файлы, позволяя кодировать пути поиска в библиотеках непосредственно в самих двоичных файлах. Общее название этой функции - поддержка run path или RPATH, хотя фактическое название может варьироваться в зависимости от платформы. Благодаря встроенным сведениям о RPATH двоичный файл может быть автономным и не зависеть от каких-либо путей, предоставляемых средой или конфигурацией системы. Кроме того, RPATH может содержать определенные заполнители, которые позволяют ему эффективно определять относительные пути, которые преобразуются в абсолютные только во время выполнения. Заполнители позволяют выполнять это разрешение на основе местоположения двоичного файла, поэтому перемещаемые пакеты могут определять подробные данные RPATH, которые содержат только жестко запрограммированные пути, основанные на относительном расположении пакета. Как и в случае со свойствами интерфейса в предыдущем разделе, существуют противоречивые требования к RPATH в дереве сборки и к установленным двоичным файлам. В дереве сборки двоичные файлы нужны разработчикам для поиска общих библиотек, на которые они ссылаются, чтобы можно было запускать исполняемые файлы (например, для отладки, выполнения тестов и так далее). На платформах, поддерживающих RPATH, CMake по умолчанию встраивает необходимые пути, тем самым предоставляя разработчикам максимально удобный интерфейс без необходимости какой-либо дополнительной настройки. Однако эти сведения о RPATH подходят только для этого конкретного дерева сборки, поэтому, когда целевые объекты установлены, CMake переписывает их с заменой путей (замена по умолчанию приводит к пустому RPATH). Значения RPATH по умолчанию являются разумной отправной точкой, но они вряд ли подойдут для установленных целевых объектов. Проекты захотят переопределить поведение по умолчанию, чтобы обеспечить соответствие как дерева сборки, так и установленных сценариев. CMake позволяет раздельно управлять расположениями RPATH для сборки и установки, поэтому проекты могут реализовывать стратегию, которая наилучшим образом соответствует их потребностям. Следующие свойства целей и переменные могут быть полезны для влияния на поведение RPATH:
- `BUILD_RPATH` Это свойство можно использовать для указания дополнительных путей поиска, которые будут встроены в бинарное дерево сборки. Это будет дополнение к путям, автоматически добавляемым CMake для зависимостей бинарного файла от ссылок, поэтому следует указывать только дополнительные пути, которые CMake не может определить самостоятельно. Это свойство необходимо только в том случае, если двоичный файл загружает несвязанные библиотеки во время выполнения с помощью dlopen() или другого эквивалентного механизма, например, при загрузке дополнительных модулей плагинов. Это свойство инициализируется значением переменной CMAKE\_BUILD\_RPATH в момент создания цели с помощью add\_library() или add\_executable(). Хотя автоматически добавляемые пути поддерживаются в CMake уже давно, свойство BUILD\_RPATH и переменная CMAKE\_BUILD\_RPATH были добавлены только в CMake 3.8.
- `BUILD_RPATH_USE_ORIGIN` Это свойство поддерживается только для CMake 3.14 или более поздней версии. Для тех платформ, которые поддерживают $ORIGIN в RPATH (см. ниже), установка этого свойства в true приводит к тому, что CMake встраивает в двоичные файлы дерева сборки не абсолютные, а относительные пути $ORIGIN. Это сделано для того, чтобы облегчить создание воспроизводимых, перемещаемых сборок. Начальное значение для BUILD\_RPATH\_USE\_ORIGIN берется из значения переменной CMAKE\_BUILD\_RPATH\_USE\_ORIGIN в момент создания цели. Это свойство влияет только на те пути, которые CMake определяет автоматически, оно не влияет на пути, указанные в свойстве BUILD\_RPATH. Оно также не будет влиять на встроенный RPATH установленных двоичных файлов.
- `INSTALL_RPATH` Это свойство задает RPATH бинарного файла при его установке. В отличие от RPATH сборки, CMake по умолчанию не предоставляет содержимого RPATH установки, поэтому проект должен установить это свойство в список путей, отражающих установленную схему. Как это сделать, описано ниже. Это свойство инициализируется значением переменной CMAKE\_INSTALL\_RPATH при создании цели.
- `INSTALL_RPATH_USE_LINK_PATH` Когда это свойство цели установлено в true, путь каждой библиотеки, на которую ссылается эта цель, добавляется в набор мест установки RPATH, но только если этот путь указывает на место за пределами исходного и бинарного каталогов проекта. Это в основном полезно для вставки абсолютных путей к внешним библиотекам, которые не являются частью проекта, но которые, как ожидается, будут находиться в одном и том же месте на всех машинах, на которых будет развернут проект. Используйте это свойство с осторожностью, поскольку такие предположения могут снизить надежность установленного пакета (пути могут измениться с будущими выпусками внешних библиотек, системные администраторы могут выбрать конфигурацию установки не по умолчанию и т. д.). Это свойство инициализируется значением переменной CMAKE\_INSTALL\_RPATH\_USE\_LINK\_PATH при создании цели.
- `BUILD_WITH_INSTALL_RPATH` В некоторых проектах используется схема сборки, зеркально отражающая схему установки. Цели могут ожидать найти определенные файлы относительно их собственного расположения, или они могут быть автономными пакетами приложений со встроенными фреймворками. В этих случаях установочный RPATH может также подходить для дерева сборки. Если задать этому целевому свойству значение true, RPATH сборки не будет использоваться, а вместо него в бинарный файл во время сборки будет встроен RPATH установки. Обратите внимание, что это может привести к проблемам при линковке, если используются плейсхолдеры, поддерживаемые загрузчиком, но не компоновщиком (об этом ниже). Это свойство инициализируется переменной CMAKE\_BUILD\_WITH\_INSTALL\_RPATH при создании цели.
- `SKIP_BUILD_RPATH` Когда это свойство цели имеет значение true, RPATH сборки не задается. BUILD\_RPATH будет игнорироваться, и CMake не будет автоматически добавлять записи RPATH для библиотек, на которые ссылается цель. Обратите внимание, что это может привести к сбою сборки, если зависимые библиотеки ссылаются на другие библиотеки, поэтому используйте это свойство с осторожностью. Это свойство инициализируется значением переменной CMAKE\_SKIP\_BUILD\_RPATH при создании цели. Оно также переопределяется BUILD\_WITH\_INSTALL\_RPATH, если это свойство установлено в true.
- `CMAKE_SKIP_INSTALL_RPATH` Эта переменная является эквивалентом CMAKE\_SKIP\_BUILD\_RPATH для установки. Установка ее в true приводит к игнорированию свойств цели INSTALL\_RPATH и, скорее всего, приведет к тому, что установленные цели не смогут найти свои зависимые библиотеки во время выполнения, поэтому ее полезность сомнительна. Обратите внимание, что целевого свойства SKIP\_INSTALL\_RPATH не существует, есть только переменная CMAKE\_SKIP\_INSTALL\_RPATH.
- `CMAKE_SKIP_RPATH` Установка этой переменной в true приводит к отключению поддержки RPATH и игнорированию всех вышеперечисленных свойств и переменных. Обычно это нежелательно делать, если только проект не управляет загрузкой библиотек во время выполнения каким-то другим способом, но в целом функциональность RPATH должна быть предпочтительнее.

Расположение RPATH при установке в идеале должно быть основано на относительных путях. На большинстве Unix-платформ это достигается использованием заполнителя $ORIGIN для обозначения местоположения бинарного файла, в который встраивается RPATH. Например, ниже приведен обычный способ определения деталей RPATH установки для проектов, которые следуют схеме, аналогичной той, что определена модулем GNUInstallDirs:
```cmake
set(CMAKE_INSTALL_RPATH $ORIGIN $ORIGIN/../lib)
```
Чтобы сделать это более надежным и учесть возможные изменения по сравнению со стандартным расположением, необходимо проделать немного больше работы. Необходимо определить относительный путь от каталога исполняемых файлов к каталогу библиотек, что можно сделать следующим образом:
```cmake
include(GNUInstallDirs)
file(RELATIVE_PATH relDir
  ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_BINDIR}
  ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}
)
set(CMAKE_INSTALL_RPATH $ORIGIN $ORIGIN/${relDir})
```
Все цели, определенные после вышеописанных, будут иметь INSTALL\_RPATH, который указывает загрузчику искать в том же каталоге, что и бинарный файл, а также что-то вроде ../lib или его эквивалент для платформы относительно местоположения бинарного файла. Таким образом, для исполняемых файлов, устанавливаемых в bin, и разделяемых библиотек, устанавливаемых в lib, это гарантирует, что и те, и другие смогут найти любые другие библиотеки, предоставляемые проектом. Это настоятельно рекомендуется в качестве отправной точки при первом добавлении поддержки RPATH в проекты. Обратите внимание, что цели Apple работают немного по-другому и могут иметь значительно отличающуюся компоновку, поэтому вышеизложенное необходимо дополнительно адаптировать для этой платформы (об этом в следующем разделе).

Одна из слабостей, о которой следует знать: в то время как загрузчики понимают $ORIGIN, компоновщик, скорее всего, не поймет. Это может привести к проблемам, когда что-то ссылается на библиотеку, которая сама ссылается на другую библиотеку. Первый уровень связывания не представляет проблемы, поскольку библиотека будет указана непосредственно в командной строке компоновщика, но второй уровень зависимости от библиотеки должен быть найден компоновщиком. Когда компоновщик не понимает $ORIGIN, он не может найти библиотеку второго уровня через RPATH. Поэтому, если путь не указан другой опцией, например -L, компоновка будет неудачной, даже если библиотека первого уровня технически содержит всю необходимую информацию. Это известная проблема, которая не относится к CMake, а является недостатком популярных компоновщиков (в частности, компоновщика GNU ld).

В зависимости от различных свойств и переменных, упомянутых выше, CMake может потребоваться изменить встроенные данные RPATH цели при ее установке. Это можно сделать двумя способами. Если двоичный файл имеет формат ELF, то по умолчанию CMake использует внутренний инструмент для переписывания RPATH непосредственно в устанавливаемом двоичном файле. Начиная с CMake 3.20, появилась эквивалентная функциональность для формата XCOFF на AIX (функция называется LIBPATH для XCOFF, но в CMake для удобства она по-прежнему обозначается как RPATH). CMake гарантирует, что для RPATH установки будет достаточно места, при необходимости увеличивая RPATH сборки. Детали того, как это делается, в основном скрыты от разработчика, за исключением, возможно, некоторых странных опций в командной строке компоновщика во время сборки. Для других бинарных форматов CMake перекомпонует бинарник во время установки, указывая вместо этого данные RPATH установки. Исторически сложилось так, что это может иногда сбивать с толку разработчиков, которые недоумевают, почему то, что уже было собрано, нужно компоновать снова, но в конечном итоге повторная компоновка - это прагматичный способ получить желаемый конечный результат. Перекомпоновка может быть принудительно реализована и для двоичных файлов ELF или XCOFF путем установки переменной CMAKE\_NO\_BUILTIN\_CHRPATH в true, но обычно это не следует использовать, если только внутреннее переписывание RPATH по какой-то причине не сработало.

При кросс-компиляции некоторые другие переменные могут изменять расположение RPATH, встроенное в двоичные файлы. Любое место RPATH, начинающееся с CMAKE\_STAGING\_PREFIX, будет автоматически заменено префиксом CMAKE\_INSTALL\_PREFIX. Это справедливо как для RPATH сборки, так и для RPATH установки. В любом установочном RPATH, начинающемся с CMAKE\_SYSROOT, этот префикс будет полностью удален.
